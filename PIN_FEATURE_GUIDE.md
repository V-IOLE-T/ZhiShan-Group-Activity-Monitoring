# Pin消息监控和提醒功能使用指南

## 功能概述

Pin消息监控功能可以自动检测群内的加精(Pin)消息变化,并提供以下能力:

1. **新增Pin提醒**: 当管理员Pin一条消息时,自动在群内发送醒目的消息卡片提醒
2. **归档管理**: 将所有Pin消息归档到专用Bitable表,便于查看历史
3. **取消Pin处理**: 当取消Pin时,静默删除归档记录(不发送提醒)
4. **被Pin次数统计**: 统计每个用户被Pin的累计次数,存储在活跃度统计表中

## 前置准备

### 1. 飞书应用权限配置

在飞书开放平台的应用管理页面,添加以下权限:

| 权限名称 | 权限代码 | 用途 |
|---------|---------|------|
| 查看Pin消息 | `im:message.pins:read` | 读取群内Pin消息列表 ✨新增 |
| 获取消息内容 | `im:message:readonly` | 获取消息详情 ✨新增 |
| 获取与发送单聊、群组消息 | `im:message` | 发送提醒消息(已有) |
| 查看、评论、编辑和管理多维表格 | `bitable:app` | 写入归档表(已有) |

**注意**: 添加权限后需要重新发布应用才能生效。

### 2. 创建Bitable表

#### 表1: Pin消息归档表

在飞书多维表格中创建新表,包含以下字段:

| 字段名 | 字段类型 | 说明 |
|-------|---------|------|
| Pin消息ID | 文本 | 消息的唯一标识 |
| 消息内容 | 多行文本 | **完整的**消息纯文本内容(富文本转纯文本,保留换行) |
| 消息类型 | 单选 | text/image/file/post等 |
| 发送者ID | 文本 | 消息发送者的user_id |
| 发送者姓名 | 文本 | 发送者昵称 |
| Pin操作人ID | 文本 | 执行Pin操作的管理员user_id |
| Pin操作人姓名 | 文本 | 管理员昵称 |
| Pin时间 | 文本 | Pin操作时间,格式: `2026-01-15 18:20:30` |
| 消息发送时间 | 文本 | 原消息发送时间,格式: `2026-01-15 18:18:20` |
| 消息链接 | URL | 跳转到该消息的链接 |
| 归档时间 | 文本 | 记录创建时间,格式: `2026-01-15 18:20:35` |
| 附件信息 | 附件 | 消息中的图片/文件(自动下载并上传) |

**字段说明**:
- **消息内容**: 使用和消息归档一致的提取方式,富文本转为纯文本,仅保留换行
- **时间字段**: 直接存储格式化的文本,无需在Bitable中转换,直接可读
- **附件信息**: 自动处理富文本中的图片、独立图片消息和文件消息

创建完成后,复制表ID(URL中`/tbl`开头的部分)。

#### 表2: 活跃度统计表(修改)

在现有的活跃度统计表中,添加新字段:

| 字段名 | 字段类型 | 说明 |
|-------|---------|------|
| 被Pin次数 | 数字 | 该用户消息被Pin的累计次数 ✨新增 |

### 3. 配置环境变量

编辑项目根目录的 `.env` 文件,添加以下配置:

```bash
# Pin消息监控配置
PIN_TABLE_ID=tblxxxxxxxxxx        # Pin消息归档表ID
PIN_MONITOR_INTERVAL=30           # 轮询间隔(秒),默认30秒,建议20-60秒
```

**获取表ID**: 打开多维表格,复制URL中 `/tbl` 开头的部分

示例:
```
https://example.feishu.cn/base/Gbx5bQqDMaTP64s6qajc/tblV0km4QpvyEBjc
                                                  ^^^^^^^^^^^^^^^^^^^
                                                  这部分就是表ID
```

## 使用方式

### 启动监控

配置完成后,直接运行主程序:

```bash
python long_connection_listener.py
```

启动日志示例:
```
🔍 Pin监控已启用 (轮询间隔: 30秒)
==================================================
🚀 飞书实时监听 [V3-STABLE] 启动
系统时间: 2026-01-15 18:00:00
目标群组: oc_xxxxx
特性: 超时重试已开启, 自动去重, 话题模式增强, 艾特去重
特性: Pin消息监控已启动
==================================================
[Pin监控] 🚀 开始监控,轮询间隔: 30秒
[Pin监控] 首次运行,缓存当前 5 条Pin消息
```

### 功能演示

#### 场景1: 新增Pin消息

**操作**: 管理员Pin一条消息

**系统行为**:
1. 30秒内检测到新Pin
2. 群内发送醒目的消息卡片:
   ```
   🔥 新增加精消息
   Pin操作人: 管理员A
   消息发送者: 用户B
   消息内容: 这是一条重要的通知...
   Pin时间: 2026-01-15 18:05:30
   [查看消息按钮]
   ```
3. 消息归档到Pin归档表
4. 用户B的"被Pin次数"+1

**日志输出**:
```
[Pin监控] 发现新Pin消息: om_abc123
[Pin监控] 消息发送者: 用户B, Pin操作人: 管理员A
[Pin监控] ✅ 发送提醒卡片成功
[Pin归档] ✅ Pin消息已归档到Bitable
[Pin统计] ✅ 用户B 被Pin次数: 2 -> 3
```

#### 场景2: 取消Pin

**操作**: 管理员取消Pin一条消息

**系统行为**:
1. 30秒内检测到Pin被取消
2. **静默删除**归档记录(不发送群内提醒)
3. 对应用户的"被Pin次数"-1

**日志输出**:
```
[Pin监控] 检测到取消Pin: om_abc123
[Pin删除] ✅ 已删除Pin归档记录
[Pin统计] ✅ 用户B 被Pin次数: 3 -> 2
```

## 监控日志说明

### 正常日志

```
[Pin监控] 当前群内Pin消息数量: 5          # 每次轮询显示
[Pin监控] 发现新Pin消息: om_xxx           # 检测到新Pin
[Pin监控] 消息发送者: 张三, Pin操作人: 李四
[Pin监控] ✅ 发送提醒卡片成功
[Pin归档] ✅ Pin消息已归档到Bitable
[Pin统计] ✅ 张三 被Pin次数: 0 -> 1
```

### 错误日志

| 错误信息 | 可能原因 | 解决方法 |
|---------|---------|---------|
| `未配置PIN_TABLE_ID` | .env中缺少配置 | 添加PIN_TABLE_ID配置 |
| `获取Pin消息失败` | 权限不足或token过期 | 检查`im:pin:readonly`权限 |
| `归档失败: 99991663` | 表ID错误 | 确认PIN_TABLE_ID正确 |
| `归档失败: 字段不存在` | 表结构不匹配 | 按照文档创建必需字段 |

## 性能说明

### API调用频率

每个轮询周期(默认30秒):
- 获取Pin消息列表: 1次 API调用
- 新增Pin时额外调用: 2-3次 (获取消息详情 + 归档 + 统计)

### 资源消耗

- **内存**: 缓存200条Pin消息详情,约1-2MB
- **网络**: 每30秒一次API请求,流量极小
- **CPU**: 后台线程,几乎无影响

### 建议配置

- **群规模小(<100人)**: 轮询间隔20-30秒
- **群规模中(100-500人)**: 轮询间隔30-60秒
- **群规模大(>500人)**: 轮询间隔60秒,Pin消息通常不会高频变化

## 常见问题

### Q1: 为什么不是实时提醒?

**A**: 飞书没有提供Pin消息的事件订阅,只能通过定期轮询检测。30秒的延迟对于Pin消息这种低频操作是可以接受的。

### Q2: 首次启动会提醒所有现有Pin吗?

**A**: 不会。首次运行时只缓存现有Pin列表,不发送提醒。只有之后新增的Pin才会触发提醒。

### Q3: 如果错过了一次轮询怎么办?

**A**: 下次轮询时仍然能检测到Pin的变化。系统通过对比Pin列表,而不是依赖单次轮询。

### Q4: 被Pin次数统计会跨月吗?

**A**: 是的。被Pin次数按月统计,和其他活跃度指标一样。每月都会重新开始计数。

### Q5: 可以自定义提醒消息样式吗?

**A**: 可以。修改 `pin_monitor.py` 中的 `send_pin_notification` 方法,自定义消息卡片的内容和样式。

### Q6: 能否禁用Pin监控?

**A**: 可以。只需在 `.env` 中删除或注释掉 `PIN_TABLE_ID`,程序启动时会显示"Pin监控未启用"。

## 进阶配置

### 调整轮询间隔

编辑 `.env`:
```bash
PIN_MONITOR_INTERVAL=20  # 改为20秒
```

**注意**: 不建议低于20秒,避免触发API频率限制(50 QPS)。

### 自定义提醒样式

修改 `pin_monitor.py` 的 `send_pin_notification` 方法:

```python
# 修改卡片颜色(orange/red/blue/green等)
"template": "red",

# 修改标题
"content": "⭐ 重要消息加精通知"

# 添加更多字段
{
    "tag": "div",
    "text": {
        "tag": "lark_md",
        "content": f"**自定义字段**: 自定义内容"
    }
}
```

### 集成到活跃度评分

如果想将被Pin次数计入活跃度评分,修改 `config.py`:

```python
ACTIVITY_WEIGHTS = {
    'message_count': 1.0,
    'char_count': 0.01,
    'reply_received': 1.5,
    'mention_received': 1.5,
    'topic_initiated': 1.0,
    'reaction_given': 1.0,
    'reaction_received': 1.0,
    'pin_received': 5.0,  # 新增: 被Pin权重(建议高权重)
}
```

然后修改 `storage.py` 的评分计算逻辑。

## 技术细节

### 检测机制

系统通过对比两次轮询的Pin消息ID列表来检测变化:

```python
new_pins = current_pin_ids - cached_pin_ids  # 新增的Pin
removed_pins = cached_pin_ids - current_pin_ids  # 取消的Pin
```

### 去重机制

使用LRU缓存存储已处理的Pin消息详情,capacity=200:
- 避免重复获取消息详情
- 取消Pin时能快速获取发送者信息
- 自动清理旧缓存,防止内存泄漏

### 容错处理

- API调用失败时记录日志但不中断主流程
- 支持优雅重启,重新加载Pin列表
- 首次运行时自动跳过现有Pin,避免误报

## 维护和排障

### 查看运行状态

观察日志输出:
```
[Pin监控] 当前群内Pin消息数量: 5  # 每30秒输出一次
```

如果长时间没有此日志,说明监控线程可能异常。

### 重启监控

如果监控出现问题,重启程序即可:

```bash
# Ctrl+C 停止程序
# 重新运行
python long_connection_listener.py
```

程序会优雅退出并清理资源:
```
🛑 收到退出信号,正在关闭...
[Pin监控] 🛑 Pin监控已停止
✅ 程序已安全退出
```

### 数据备份

建议定期备份Pin归档表和活跃度统计表,避免数据丢失。

## 版本历史

- **v1.0** (2026-01-15): 初始版本
  - 基础Pin监控
  - 群内提醒
  - Bitable归档
  - 被Pin次数统计

## 反馈和支持

如有问题,请提交GitHub Issue或联系开发者。
